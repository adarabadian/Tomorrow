{"ast":null,"code":"import { evaluateAlertCondition } from '../utils/alertUtils';\n// Helper function to map the backend Alert model to our frontend Alert model\nexport const mapBackendAlert = backendAlert => {\n  // Get the explicitly defined isTriggered value from backend\n  let isTriggered = backendAlert.isTriggered !== undefined ? backendAlert.isTriggered : false;\n\n  // Re-evaluate based on lastValue and threshold if all required data is present\n  if (backendAlert.lastValue !== undefined && backendAlert.parameter && backendAlert.condition && backendAlert.threshold !== undefined) {\n    isTriggered = evaluateAlertCondition(backendAlert.parameter, backendAlert.condition, backendAlert.threshold, backendAlert.lastValue);\n  }\n\n  // Status should be derived directly from isTriggered for consistency\n  const status = isTriggered ? 'active' : 'inactive';\n  return {\n    id: backendAlert.id || backendAlert._id,\n    _id: backendAlert._id || backendAlert.id,\n    name: backendAlert.name,\n    location: backendAlert.location,\n    resolvedLocation: backendAlert.resolvedLocation,\n    parameter: backendAlert.parameter,\n    threshold: backendAlert.threshold,\n    condition: backendAlert.condition,\n    description: backendAlert.description,\n    userEmail: backendAlert.userEmail || '',\n    status: status,\n    isTriggered: isTriggered,\n    lastChecked: backendAlert.lastChecked || new Date().toISOString(),\n    lastValue: backendAlert.lastValue\n  };\n};","map":{"version":3,"names":["evaluateAlertCondition","mapBackendAlert","backendAlert","isTriggered","undefined","lastValue","parameter","condition","threshold","status","id","_id","name","location","resolvedLocation","description","userEmail","lastChecked","Date","toISOString"],"sources":["C:/Users/adara/Desktop/aaa/Tomorrow/frontend/src/types/alert.ts"],"sourcesContent":["import { evaluateAlertCondition } from '../utils/alertUtils';\r\n\r\nexport interface Alert {\r\n  id: string;\r\n  _id: string; // MongoDB-style ID for compatibility\r\n  name: string;\r\n  location: {\r\n    city?: string;\r\n    coordinates?: {\r\n      lat: number;\r\n      lon: number;\r\n    };\r\n  };\r\n  resolvedLocation?: string;\r\n  parameter: string;\r\n  threshold: number;\r\n  condition: string;\r\n  userEmail: string;\r\n  description?: string;\r\n  status: 'active' | 'inactive';\r\n  isTriggered: boolean;\r\n  lastChecked: string;\r\n  lastValue?: number;\r\n}\r\n\r\nexport interface CreateAlertPayload {\r\n  name: string;\r\n  location: {\r\n    city?: string;\r\n    coordinates?: {\r\n      lat: number;\r\n      lon: number;\r\n    };\r\n  };\r\n  parameter: string;\r\n  threshold: number;\r\n  condition: string;\r\n  description?: string;\r\n  userEmail: string;\r\n}\r\n\r\nexport interface AlertSummary {\r\n  id: string;\r\n  name: string;\r\n  parameter: string;\r\n  isTriggered: boolean;\r\n}\r\n\r\n// Helper function to map the backend Alert model to our frontend Alert model\r\nexport const mapBackendAlert = (backendAlert: any): Alert => {\r\n  // Get the explicitly defined isTriggered value from backend\r\n  let isTriggered = backendAlert.isTriggered !== undefined ? backendAlert.isTriggered : false;\r\n  \r\n  // Re-evaluate based on lastValue and threshold if all required data is present\r\n  if (backendAlert.lastValue !== undefined && \r\n      backendAlert.parameter && \r\n      backendAlert.condition && \r\n      backendAlert.threshold !== undefined) {\r\n    isTriggered = evaluateAlertCondition(\r\n      backendAlert.parameter,\r\n      backendAlert.condition,\r\n      backendAlert.threshold,\r\n      backendAlert.lastValue\r\n    );\r\n  }\r\n  \r\n  // Status should be derived directly from isTriggered for consistency\r\n  const status = isTriggered ? 'active' : 'inactive';\r\n  \r\n  return {\r\n    id: backendAlert.id || backendAlert._id,\r\n    _id: backendAlert._id || backendAlert.id,\r\n    name: backendAlert.name,\r\n    location: backendAlert.location,\r\n    resolvedLocation: backendAlert.resolvedLocation,\r\n    parameter: backendAlert.parameter,\r\n    threshold: backendAlert.threshold,\r\n    condition: backendAlert.condition,\r\n    description: backendAlert.description,\r\n    userEmail: backendAlert.userEmail || '',\r\n    status: status,\r\n    isTriggered: isTriggered,\r\n    lastChecked: backendAlert.lastChecked || new Date().toISOString(),\r\n    lastValue: backendAlert.lastValue\r\n  };\r\n}; "],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,qBAAqB;AAgD5D;AACA,OAAO,MAAMC,eAAe,GAAIC,YAAiB,IAAY;EAC3D;EACA,IAAIC,WAAW,GAAGD,YAAY,CAACC,WAAW,KAAKC,SAAS,GAAGF,YAAY,CAACC,WAAW,GAAG,KAAK;;EAE3F;EACA,IAAID,YAAY,CAACG,SAAS,KAAKD,SAAS,IACpCF,YAAY,CAACI,SAAS,IACtBJ,YAAY,CAACK,SAAS,IACtBL,YAAY,CAACM,SAAS,KAAKJ,SAAS,EAAE;IACxCD,WAAW,GAAGH,sBAAsB,CAClCE,YAAY,CAACI,SAAS,EACtBJ,YAAY,CAACK,SAAS,EACtBL,YAAY,CAACM,SAAS,EACtBN,YAAY,CAACG,SACf,CAAC;EACH;;EAEA;EACA,MAAMI,MAAM,GAAGN,WAAW,GAAG,QAAQ,GAAG,UAAU;EAElD,OAAO;IACLO,EAAE,EAAER,YAAY,CAACQ,EAAE,IAAIR,YAAY,CAACS,GAAG;IACvCA,GAAG,EAAET,YAAY,CAACS,GAAG,IAAIT,YAAY,CAACQ,EAAE;IACxCE,IAAI,EAAEV,YAAY,CAACU,IAAI;IACvBC,QAAQ,EAAEX,YAAY,CAACW,QAAQ;IAC/BC,gBAAgB,EAAEZ,YAAY,CAACY,gBAAgB;IAC/CR,SAAS,EAAEJ,YAAY,CAACI,SAAS;IACjCE,SAAS,EAAEN,YAAY,CAACM,SAAS;IACjCD,SAAS,EAAEL,YAAY,CAACK,SAAS;IACjCQ,WAAW,EAAEb,YAAY,CAACa,WAAW;IACrCC,SAAS,EAAEd,YAAY,CAACc,SAAS,IAAI,EAAE;IACvCP,MAAM,EAAEA,MAAM;IACdN,WAAW,EAAEA,WAAW;IACxBc,WAAW,EAAEf,YAAY,CAACe,WAAW,IAAI,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;IACjEd,SAAS,EAAEH,YAAY,CAACG;EAC1B,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
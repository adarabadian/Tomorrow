{"ast":null,"code":"import { evaluateAlertCondition } from '../utils/alertUtils';\n// Helper function to map the backend Alert model to our frontend Alert model\nexport const mapBackendAlert = backendAlert => {\n  console.log('Mapping backend alert to frontend model:', backendAlert);\n\n  // Get backend values - this is the source of truth from the backend\n  const backendLastValue = backendAlert.lastValue;\n\n  // Always recalculate isTriggered based on lastValue and threshold\n  let isTriggered = false;\n  if (backendLastValue !== undefined && backendAlert.parameter && backendAlert.condition && backendAlert.threshold !== undefined) {\n    try {\n      // Calculate isTriggered based on the actual data\n      isTriggered = evaluateAlertCondition(backendAlert.parameter, backendAlert.condition, backendAlert.threshold, backendLastValue);\n      console.log(`Alert ${backendAlert.name}: Evaluated condition: ${backendAlert.parameter} ${backendAlert.condition} ${backendAlert.threshold} with last value ${backendLastValue} = ${isTriggered}`);\n    } catch (err) {\n      console.error(`Error evaluating alert ${backendAlert.name}:`, err);\n      // Fall back to backend value if calculation fails\n      isTriggered = backendAlert.isTriggered === true;\n      console.log(`Alert ${backendAlert.name}: Using backend isTriggered = ${isTriggered}`);\n    }\n  } else {\n    // Can't calculate, use backend value\n    isTriggered = backendAlert.isTriggered === true;\n    console.log(`Alert ${backendAlert.name}: No data to calculate, using backend isTriggered = ${isTriggered}`);\n  }\n\n  // status is ALWAYS derived from isTriggered\n  const status = isTriggered ? 'active' : 'inactive';\n  return {\n    id: backendAlert.id || backendAlert._id,\n    _id: backendAlert._id || backendAlert.id,\n    name: backendAlert.name,\n    location: backendAlert.location,\n    resolvedLocation: backendAlert.resolvedLocation,\n    parameter: backendAlert.parameter,\n    threshold: backendAlert.threshold,\n    condition: backendAlert.condition,\n    description: backendAlert.description,\n    userEmail: backendAlert.userEmail || '',\n    status: status,\n    isTriggered: isTriggered,\n    // Only the calculated value\n    lastChecked: backendAlert.lastChecked || new Date().toISOString(),\n    lastValue: backendLastValue\n  };\n};","map":{"version":3,"names":["evaluateAlertCondition","mapBackendAlert","backendAlert","console","log","backendLastValue","lastValue","isTriggered","undefined","parameter","condition","threshold","name","err","error","status","id","_id","location","resolvedLocation","description","userEmail","lastChecked","Date","toISOString"],"sources":["C:/Users/adara/Desktop/aaa/Tomorrow/frontend/src/types/alert.ts"],"sourcesContent":["import { evaluateAlertCondition } from '../utils/alertUtils';\r\n\r\nexport interface Alert {\r\n  id: string;\r\n  _id: string; // MongoDB-style ID for compatibility\r\n  name: string;\r\n  location: {\r\n    city?: string;\r\n    coordinates?: {\r\n      lat: number;\r\n      lon: number;\r\n    };\r\n  };\r\n  resolvedLocation?: string;\r\n  parameter: string;\r\n  threshold: number;\r\n  condition: string;\r\n  userEmail: string;\r\n  description?: string;\r\n  status: 'active' | 'inactive';\r\n  isTriggered: boolean;\r\n  lastChecked: string;\r\n  lastValue?: number;\r\n}\r\n\r\nexport interface CreateAlertPayload {\r\n  name: string;\r\n  location: {\r\n    city?: string;\r\n    coordinates?: {\r\n      lat: number;\r\n      lon: number;\r\n    };\r\n  };\r\n  parameter: string;\r\n  threshold: number;\r\n  condition: string;\r\n  description?: string;\r\n  userEmail: string;\r\n}\r\n\r\nexport interface AlertSummary {\r\n  id: string;\r\n  name: string;\r\n  parameter: string;\r\n  isTriggered: boolean;\r\n}\r\n\r\n// Helper function to map the backend Alert model to our frontend Alert model\r\nexport const mapBackendAlert = (backendAlert: any): Alert => {\r\n  console.log('Mapping backend alert to frontend model:', backendAlert);\r\n  \r\n  // Get backend values - this is the source of truth from the backend\r\n  const backendLastValue = backendAlert.lastValue;\r\n  \r\n  // Always recalculate isTriggered based on lastValue and threshold\r\n  let isTriggered = false;\r\n  \r\n  if (backendLastValue !== undefined && \r\n      backendAlert.parameter && \r\n      backendAlert.condition && \r\n      backendAlert.threshold !== undefined) {\r\n    try {\r\n      // Calculate isTriggered based on the actual data\r\n      isTriggered = evaluateAlertCondition(\r\n        backendAlert.parameter,\r\n        backendAlert.condition,\r\n        backendAlert.threshold,\r\n        backendLastValue\r\n      );\r\n      console.log(`Alert ${backendAlert.name}: Evaluated condition: ${backendAlert.parameter} ${backendAlert.condition} ${backendAlert.threshold} with last value ${backendLastValue} = ${isTriggered}`);\r\n    } catch (err) {\r\n      console.error(`Error evaluating alert ${backendAlert.name}:`, err);\r\n      // Fall back to backend value if calculation fails\r\n      isTriggered = backendAlert.isTriggered === true;\r\n      console.log(`Alert ${backendAlert.name}: Using backend isTriggered = ${isTriggered}`);\r\n    }\r\n  } else {\r\n    // Can't calculate, use backend value\r\n    isTriggered = backendAlert.isTriggered === true;\r\n    console.log(`Alert ${backendAlert.name}: No data to calculate, using backend isTriggered = ${isTriggered}`);\r\n  }\r\n  \r\n  // status is ALWAYS derived from isTriggered\r\n  const status = isTriggered ? 'active' : 'inactive';\r\n  \r\n  return {\r\n    id: backendAlert.id || backendAlert._id,\r\n    _id: backendAlert._id || backendAlert.id,\r\n    name: backendAlert.name,\r\n    location: backendAlert.location,\r\n    resolvedLocation: backendAlert.resolvedLocation,\r\n    parameter: backendAlert.parameter,\r\n    threshold: backendAlert.threshold,\r\n    condition: backendAlert.condition,\r\n    description: backendAlert.description,\r\n    userEmail: backendAlert.userEmail || '',\r\n    status: status,\r\n    isTriggered: isTriggered, // Only the calculated value\r\n    lastChecked: backendAlert.lastChecked || new Date().toISOString(),\r\n    lastValue: backendLastValue\r\n  };\r\n}; "],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,qBAAqB;AAgD5D;AACA,OAAO,MAAMC,eAAe,GAAIC,YAAiB,IAAY;EAC3DC,OAAO,CAACC,GAAG,CAAC,0CAA0C,EAAEF,YAAY,CAAC;;EAErE;EACA,MAAMG,gBAAgB,GAAGH,YAAY,CAACI,SAAS;;EAE/C;EACA,IAAIC,WAAW,GAAG,KAAK;EAEvB,IAAIF,gBAAgB,KAAKG,SAAS,IAC9BN,YAAY,CAACO,SAAS,IACtBP,YAAY,CAACQ,SAAS,IACtBR,YAAY,CAACS,SAAS,KAAKH,SAAS,EAAE;IACxC,IAAI;MACF;MACAD,WAAW,GAAGP,sBAAsB,CAClCE,YAAY,CAACO,SAAS,EACtBP,YAAY,CAACQ,SAAS,EACtBR,YAAY,CAACS,SAAS,EACtBN,gBACF,CAAC;MACDF,OAAO,CAACC,GAAG,CAAC,SAASF,YAAY,CAACU,IAAI,0BAA0BV,YAAY,CAACO,SAAS,IAAIP,YAAY,CAACQ,SAAS,IAAIR,YAAY,CAACS,SAAS,oBAAoBN,gBAAgB,MAAME,WAAW,EAAE,CAAC;IACpM,CAAC,CAAC,OAAOM,GAAG,EAAE;MACZV,OAAO,CAACW,KAAK,CAAC,0BAA0BZ,YAAY,CAACU,IAAI,GAAG,EAAEC,GAAG,CAAC;MAClE;MACAN,WAAW,GAAGL,YAAY,CAACK,WAAW,KAAK,IAAI;MAC/CJ,OAAO,CAACC,GAAG,CAAC,SAASF,YAAY,CAACU,IAAI,iCAAiCL,WAAW,EAAE,CAAC;IACvF;EACF,CAAC,MAAM;IACL;IACAA,WAAW,GAAGL,YAAY,CAACK,WAAW,KAAK,IAAI;IAC/CJ,OAAO,CAACC,GAAG,CAAC,SAASF,YAAY,CAACU,IAAI,uDAAuDL,WAAW,EAAE,CAAC;EAC7G;;EAEA;EACA,MAAMQ,MAAM,GAAGR,WAAW,GAAG,QAAQ,GAAG,UAAU;EAElD,OAAO;IACLS,EAAE,EAAEd,YAAY,CAACc,EAAE,IAAId,YAAY,CAACe,GAAG;IACvCA,GAAG,EAAEf,YAAY,CAACe,GAAG,IAAIf,YAAY,CAACc,EAAE;IACxCJ,IAAI,EAAEV,YAAY,CAACU,IAAI;IACvBM,QAAQ,EAAEhB,YAAY,CAACgB,QAAQ;IAC/BC,gBAAgB,EAAEjB,YAAY,CAACiB,gBAAgB;IAC/CV,SAAS,EAAEP,YAAY,CAACO,SAAS;IACjCE,SAAS,EAAET,YAAY,CAACS,SAAS;IACjCD,SAAS,EAAER,YAAY,CAACQ,SAAS;IACjCU,WAAW,EAAElB,YAAY,CAACkB,WAAW;IACrCC,SAAS,EAAEnB,YAAY,CAACmB,SAAS,IAAI,EAAE;IACvCN,MAAM,EAAEA,MAAM;IACdR,WAAW,EAAEA,WAAW;IAAE;IAC1Be,WAAW,EAAEpB,YAAY,CAACoB,WAAW,IAAI,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;IACjElB,SAAS,EAAED;EACb,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}